#!/usr/bin/ruby

require 'rubygems'
require 'hpricot'
require 'open-uri'
require 'uri'
require 'optparse'

class IsohuntSearch
  def initialize(arguments, stdin)
    @input, @options = process_arguments(arguments, stdin)
  end

  def fetch_torrent_uri(details_path)
    details = Hpricot(open("http://isohunt.com#{details_path}"), 'User-Agent' => 'Firefox')
    
    "http://isohunt.com" + (details/'img[@src="/img/dl-trans.gif"]').first.parent[:href]
  end

  def run()
    if @options[:get]
      puts fetch_torrent_uri("/torrent_details/#{@options[:get]}")
      exit 0
    end
    
    search = Hpricot(open("http://isohunt.com/torrents/#{URI.escape(@input[:terms])}?iht=-1&ihp=1&ihs1=2&iho1=d", 'User-Agent' => 'Firefox'))
    
    torrents = []
    
    (search/'a').each do |a|
      next if !a[:href] || !a[:href].match(/^\/torrent_details/) || !a[:href].match(/tab=summary/)
      
      torrents << {
        :id => a[:href].match(/\/torrent_details\/(\d+)/)[1],
        :details_path => a[:href],
        :name => a.inner_text,
        :rating => a.parent.search('a').first[:title].match(/(\D?\d+) rating/)[1],
        :comments => a.parent.search('a').first[:title].match(/(\d+) comments/)[1],
        :size => a.parent.next.inner_text,
        :seeders => a.parent.next.next.inner_text,
        :leechers => a.parent.next.next.next.inner_text
      }
    end

    if @options[:search]
      torrents = [{:id => "ID", :seeders => "S", :leechers => "L", :rating => "R", :comments => "C", :size => "Size", :name => "Name"}] + torrents;

      id_size = torrents.collect{|t| t[:id].length}.sort.last
      seedleech_size = torrents.collect{|t| t[:seeders].length + t[:leechers].length + 1}.sort.last
      ratecomment_size = torrents.collect{|t| t[:rating].length + t[:comments].length + 1}.sort.last
      size_size = torrents.collect{|t| t[:size].length}.sort.last
      name_size = torrents.collect{|t| t[:name].length}.sort.last

      format = "%-#{id_size}s  %-#{seedleech_size}s  %-#{ratecomment_size}s  %-#{size_size}s  %-#{name_size}s\n"

      torrents.each do |t| 
        printf(format, t[:id], "#{t[:seeders]}/#{t[:leechers]}", "#{t[:rating]}/#{t[:comments]}", t[:size], t[:name])
      end
    else
      puts fetch_torrent_uri(torrents[0][:details_path])
    end

    1
  end

  def process_arguments(arguments, stdin)
    options = {}
    
    options[:help] = false
    options[:get] = nil
    options[:search] = false

    opts = OptionParser.new do |opts|
      opts.banner = "Usage: isohunt [options] <search terms>"
      
      opts.separator(" ")
      opts.separator("By default, isohunt will emit the URI of the torrent that matches your terms and")
      opts.separator("has the most seeds. To override this behaviour, you can use -s to display search")
      opts.separator("results, and -g to emit the URI of the torrent for a specific result")
      opts.separator(" ")

      opts.separator("Options:")

      opts.on("-s", "--search", "Display results rather than emitting the best-looking torrent's URI.") do |search|
        options[:search] = search
      end

      opts.on("-g ID", "--get ID", "Retreive the .torrent URI for the specified result") do |id|
        options[:get] = id
      end

      opts.on_tail("-h", "--help", "This help information") do |help|
         puts opts
         exit 1
      end
      
      opts.parse!(arguments)
      options
    end
  
    input = {:terms => arguments[0]}
    
    if !options[:get] && !input[:terms]
      input[:terms] = stdin.read
    end

    [input, options]
  end
end

ihs = IsohuntSearch.new(ARGV, STDIN)
ihs.run

